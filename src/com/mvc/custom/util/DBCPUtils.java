package com.mvc.custom.util;

import java.io.InputStream;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;
import java.util.Properties;

import javax.sql.DataSource;

import org.apache.commons.dbcp.BasicDataSourceFactory;


public class DBCPUtils {
	private static DataSource ds;
	private static Connection conn=null;
	private static PreparedStatement prep=null;
	private static ResultSet res=null;
	private static boolean autoCommit;
	
    static{
        try {
        	InputStream is=DBCPUtils.class.getClassLoader().getResourceAsStream("dbcp.properties");
			Properties prop=new Properties();	
			prop.load(is);		
			ds=BasicDataSourceFactory.createDataSource(prop);
        } catch (Exception e) {
        	e.printStackTrace();
            throw new ExceptionInInitializerError("");
        }
    }
  	public static DataSource getDataSource(){
  		return ds;
  	}
    
    public static Connection getConnection() throws SQLException{
    	conn = ds.getConnection();
        return conn;
    }
    
    public static void closeAll(){
        if(res!=null){
            try {
                res.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        
        if(prep!=null){
            try {
                prep.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
        
        if(conn!=null){
            try {
                conn.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

	public static Statement statement() throws SQLException {
		Statement st = null;
		getConnection();
		/* 如果连接是无效的就重新连接 */
		/* 设置事务的提交方式 */
		try {
			st = conn.createStatement();
		} catch (SQLException e) {
			System.out.println("创建 Statement 对象失败: " + e.getMessage());
		}

		return st;
	}

	/**
	 * 根据给定的带参数占位符的SQL语句，创建 PreparedStatement 对象
	 * 
	 * @param SQL
	 *            带参数占位符的SQL语句
	 * @return 返回相应的 PreparedStatement 对象
	 * @throws SQLException 
	 */
	private static PreparedStatement prepare(String SQL, boolean autoGeneratedKeys) throws SQLException {

		PreparedStatement ps = null;
		getConnection();
		/* 如果连接是无效的就重新连接 */
		try {
			if (autoGeneratedKeys) {
				ps = conn.prepareStatement(SQL, Statement.RETURN_GENERATED_KEYS);
			} else {
				ps = conn.prepareStatement(SQL);
			}
		} catch (SQLException e) {
			System.out.println("创建 PreparedStatement 对象失败: " + e.getMessage());
		}

		return ps;

	}

	public static ResultSet query(String SQL, List<Object> params) throws SQLException {

		if (SQL == null || SQL.trim().isEmpty() || !SQL.trim().toLowerCase().startsWith("select")) {
			throw new RuntimeException("你的SQL语句为空或不是查询语句");
		}
		ResultSet rs = null;
		if (params != null && params.size() > 0) {
			/* 说明 有参数 传入，就需要处理参数 */
			PreparedStatement ps = prepare(SQL, false);
			try {
				for (int i = 0; i < params.size(); i++) {
					ps.setObject(i + 1, params.get(i));
				}
				rs = ps.executeQuery();
			} catch (SQLException e) {
				System.out.println("执行SQL失败: " + e.getMessage());
			}
		} else {
			/* 说明没有传入任何参数 */
			Statement st = statement();
			try {
				rs = st.executeQuery(SQL); // 直接执行不带参数的 SQL 语句
			} catch (SQLException e) {
				System.out.println("执行SQL失败: " + e.getMessage());
			}
		}
		return rs;

	}

//	private static Object typeof(Object o) {
//		Object r = o;
//
//		if (o instanceof java.sql.Timestamp) {
//			return r;
//		}
//		// 将 java.util.Date 转成 java.sql.Date
//		if (o instanceof java.util.Date) {
//			java.util.Date d = (java.util.Date) o;
//			r = new java.sql.Date(d.getTime());
//			return r;
//		}
//		// 将 Character 或 char 变成 String
//		if (o instanceof Character || o.getClass() == char.class) {
//			r = String.valueOf(o);
//			return r;
//		}
//		return r;
//	}

	public static boolean execute(String SQL, Object... params) throws SQLException {
		if (SQL == null || SQL.trim().isEmpty() || SQL.trim().toLowerCase().startsWith("select")) {
			throw new RuntimeException("你的SQL语句为空或有错");
		}
		boolean r = false;
		/* 表示 执行 DDL 或 DML 操作是否成功的一个标识变量 */

		/* 获得 被执行的 SQL 语句的 前缀 */
		SQL = SQL.trim();
		SQL = SQL.toLowerCase();
		String prefix = SQL.substring(0, SQL.indexOf(" "));
		String operation = ""; // 用来保存操作类型的 变量
		// 根据前缀 确定操作
		switch (prefix) {
		case "create":
			operation = "create table";
			break;
		case "alter":
			operation = "update table";
			break;
		case "drop":
			operation = "drop table";
			break;
		case "truncate":
			operation = "truncate table";
			break;
		case "insert":
			operation = "insert :";
			break;
		case "update":
			operation = "update :";
			break;
		case "delete":
			operation = "delete :";
			break;
		}
		if (params.length > 0) { // 说明有参数
			PreparedStatement ps = prepare(SQL, false);
			Connection c = null;
			try {
				c = ps.getConnection();
			} catch (SQLException e) {
				e.printStackTrace();
			}
			try {
				for (int i = 0; i < params.length; i++) {
					Object p = params[i];
//					p = typeof(p);
					ps.setObject(i + 1, p);
				}
				ps.executeUpdate();
				r = true;
			} catch (SQLException e) {
				System.out.println(operation + " 失败: " + e.getMessage());
			}

		} else { // 说明没有参数

			Statement st = statement();
			Connection c = null;
			try {
				c = st.getConnection();
			} catch (SQLException e) {
				e.printStackTrace();
			}
			// 执行 DDL 或 DML 语句，并返回执行结果
			try {
				st.executeUpdate(SQL);
				r = true;
			} catch (SQLException e) {
				System.out.println(operation + " 失败: " + e.getMessage());
			}
		}
		return r;
	}

	/*
	 * 
	 * @param SQL 需要执行的 INSERT 语句
	 * 
	 * @param autoGeneratedKeys 指示是否需要返回由数据库产生的键
	 * 
	 * @param params 将要执行的SQL语句中包含的参数占位符的 参数值
	 * 
	 * @return 如果指定 autoGeneratedKeys 为 true 则返回由数据库产生的键； 如果指定 autoGeneratedKeys
	 * 为 false 则返回受当前SQL影响的记录数目
	 */
	public static int insert(String SQL, boolean autoGeneratedKeys, List<Object> params) throws SQLException {
		int var = -1;
		if (SQL == null || SQL.trim().isEmpty()) {
			throw new RuntimeException("你没有指定SQL语句，请检查是否指定了需要执行的SQL语句");
		}
		// 如果不是 insert 开头开头的语句
		if (!SQL.trim().toLowerCase().startsWith("insert")) {
			System.out.println(SQL.toLowerCase());
			throw new RuntimeException("你指定的SQL语句不是插入语句，请检查你的SQL语句");
		}
		// 获得 被执行的 SQL 语句的 前缀 ( 第一个单词 )
		SQL = SQL.trim();
		SQL = SQL.toLowerCase();
		System.out.println(SQL);
		if (params.size() > 0) { // 说明有参数
			PreparedStatement ps = prepare(SQL, autoGeneratedKeys);
			try {
				for (int i = 0; i < params.size(); i++) {
					Object p = params.get(i);
//					p = typeof(p);
					ps.setObject(i + 1, p);
				}
				int count = ps.executeUpdate();
				if (autoGeneratedKeys) { // 如果希望获得数据库产生的键
					ResultSet rs = ps.getGeneratedKeys(); // 获得数据库产生的键集
					if (rs.next()) { // 因为是保存的是单条记录，因此至多返回一个键
						var = rs.getInt(1); // 获得值并赋值给 var 变量
					}
				} else {
					var = count; // 如果不需要获得，则将受SQL影像的记录数赋值给 var 变量
				}
			} catch (SQLException e) {
				System.out.println("数据保存失败: " + e.getMessage());
			}
		} else { // 说明没有参数
			Statement st = statement();
			Connection c = null;
			try {
				c = st.getConnection(); // 从 Statement 对象中获得 它对应的连接对象
			} catch (SQLException e) {
				e.printStackTrace();
			}
			// 执行 DDL 或 DML 语句，并返回执行结果
			try {
				int count = st.executeUpdate(SQL);
				if (autoGeneratedKeys) { // 如果企望获得数据库产生的键
					ResultSet rs = st.getGeneratedKeys(); // 获得数据库产生的键集
					if (rs.next()) { // 因为是保存的是单条记录，因此至多返回一个键
						var = rs.getInt(1); // 获得值并赋值给 var 变量
					}
				} else {
					var = count; // 如果不需要获得，则将受SQL影像的记录数赋值给 var 变量
				}
			} catch (SQLException e) {
				System.out.println("数据保存失败: " + e.getMessage());
			}
		}
		closeAll();
		return var;
	}
	
	public static int update(String SQL, boolean autoGeneratedKeys, List<Object> params) throws SQLException {
		int var = -1;
		if (SQL == null || SQL.trim().isEmpty()) {
			throw new RuntimeException("你没有指定SQL语句，请检查是否指定了需要执行的SQL语句");
		}
		if (!SQL.trim().toLowerCase().startsWith("update")) {
			System.out.println(SQL.toLowerCase());
			throw new RuntimeException("你指定的SQL语句不是修改语句，请检查你的SQL语句");
		}
		SQL = SQL.trim();
		SQL = SQL.toLowerCase();
		if (params.size() > 0) { // 说明有参数
			PreparedStatement ps = prepare(SQL, autoGeneratedKeys);
			Connection c = null;
			try {
				c = ps.getConnection(); // 从 PreparedStatement 对象中获得 它对应的连接对象
			} catch (SQLException e) {
				e.printStackTrace();
			}
			try {
				for (int i = 0; i < params.size(); i++) {
					Object p = params.get(i);
//					p = typeof(p);
					ps.setObject(i + 1, p);
				}
				int count = ps.executeUpdate();
				if (autoGeneratedKeys) { // 如果希望获得数据库产生的键
					ResultSet rs = ps.getGeneratedKeys(); // 获得数据库产生的键集
					if (rs.next()) { // 因为是保存的是单条记录，因此至多返回一个键
						var = rs.getInt(1); // 获得值并赋值给 var 变量
					}
				} else {
					var = count; // 如果不需要获得，则将受SQL影像的记录数赋值给 var 变量
				}
			} catch (SQLException e) {
				System.out.println("数据保存失败: " + e.getMessage());
			}
		} else { // 说明没有参数
			Statement st = statement();
			Connection c = null;
			try {
				c = st.getConnection(); // 从 Statement 对象中获得 它对应的连接对象
			} catch (SQLException e) {
				e.printStackTrace();
			}
			// 执行 DDL 或 DML 语句，并返回执行结果
			try {
				int count = st.executeUpdate(SQL);
				if (autoGeneratedKeys) { // 如果企望获得数据库产生的键
					ResultSet rs = st.getGeneratedKeys(); // 获得数据库产生的键集
					if (rs.next()) { // 因为是保存的是单条记录，因此至多返回一个键
						var = rs.getInt(1); // 获得值并赋值给 var 变量
					}
				} else {
					var = count; // 如果不需要获得，则将受SQL影像的记录数赋值给 var 变量
				}
			} catch (SQLException e) {
				System.out.println("数据保存失败: " + e.getMessage());
			}
		}
		return var;
		
	}

	public static int delete(String SQL, boolean autoGeneratedKeys, List<Object> params) throws SQLException {
		int var = -1;
		if (SQL == null || SQL.trim().isEmpty()) {
			throw new RuntimeException("你没有指定SQL语句，请检查是否指定了需要执行的SQL语句");
		}
		if (!SQL.trim().toLowerCase().startsWith("delete")) {
			System.out.println(SQL.toLowerCase());
			throw new RuntimeException("你指定的SQL语句不是删除语句，请检查你的SQL语句");
		}
		SQL = SQL.trim();
		SQL = SQL.toLowerCase();
		if (params.size() > 0) { // 说明有参数
			PreparedStatement ps = prepare(SQL, autoGeneratedKeys);
			Connection c = null;
			try {
				c = ps.getConnection(); // 从 PreparedStatement 对象中获得 它对应的连接对象
			} catch (SQLException e) {
				e.printStackTrace();
			}
			try {
				for (int i = 0; i < params.size(); i++) {
					Object p = params.get(i);
//					p = typeof(p);
					ps.setObject(i + 1, p);
				}
				int count = ps.executeUpdate();
				if (autoGeneratedKeys) { // 如果希望获得数据库产生的键
					ResultSet rs = ps.getGeneratedKeys(); // 获得数据库产生的键集
					if (rs.next()) { // 因为是保存的是单条记录，因此至多返回一个键
						var = rs.getInt(1); // 获得值并赋值给 var 变量
					}
				} else {
					var = count; // 如果不需要获得，则将受SQL影像的记录数赋值给 var 变量
				}
			} catch (SQLException e) {
				System.out.println("数据保存失败: " + e.getMessage());
			}
		} else { // 说明没有参数
			Statement st = statement();
			Connection c = null;
			try {
				c = st.getConnection(); // 从 Statement 对象中获得 它对应的连接对象
			} catch (SQLException e) {
				e.printStackTrace();
			}
			// 执行 DDL 或 DML 语句，并返回执行结果
			try {
				int count = st.executeUpdate(SQL);
				if (autoGeneratedKeys) { // 如果企望获得数据库产生的键
					ResultSet rs = st.getGeneratedKeys(); // 获得数据库产生的键集
					if (rs.next()) { // 因为是保存的是单条记录，因此至多返回一个键
						var = rs.getInt(1); // 获得值并赋值给 var 变量
					}
				} else {
					var = count; // 如果不需要获得，则将受SQL影像的记录数赋值给 var 变量
				}
			} catch (SQLException e) {
				System.out.println("数据保存失败: " + e.getMessage());
			}
		}
		return var;
	}
	
}
